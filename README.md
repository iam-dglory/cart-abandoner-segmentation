# Cart Abandoner MECE Segmentation & Retention Strategy

## **Project Overview**
This project implements a **Mutually Exclusive, Collectively Exhaustive (MECE) segmentation system** for users who abandoned carts in the last 7 days.  
The goal is to create actionable audience segments that marketers can target for retention campaigns.  
Segments are scored based on **conversion potential, profitability, lift, and size**, and then **reranked** to prioritize high-value audiences.

---

## **Folder Structure**

cart-abandoner-segmentation/
│── src/
│ └── segment_pipeline.py # Core MECE segmentation pipeline
│── tests/
│ └── test_mece.py # Unit tests for MECE validation
│── notebooks/
│ └── demo_segmentation.ipynb # Optional demo & visualization
│── output/
│ ├── segments_summary.csv
│ └── segments_summary.json
│── requirements.txt
│── README.md
│── .gitignore


- `output/` files are generated by running the pipeline.  
- `.gitignore` excludes virtual environments, cache files, outputs, and raw data files.

---

## **Setup & Running the Pipeline**

1. **Create and activate virtual environment**
```bash
python -m venv venv
.\venv\Scripts\activate
Install dependencies

pip install -r requirements.txt


Run MECE segmentation

python -m src.segment_pipeline


Generates CSV & JSON outputs in output/ folder

Optional: displays a pie chart of segment distribution

Run unit tests

pytest -q


Validates MECE segmentation, ELSE bucket, and scoring logic

Segmentation Logic

Segments are built using three features:

Average Order Value (AOV)

Low: AOV ≤ 1000

Mid: 1000 < AOV ≤ 3000

High: AOV > 3000

Engagement Score

Low: ≤ 0.3

Mid: 0.3 < score ≤ 0.6

High: > 0.6

Profitability Score

Low: ≤ 0.7

High: > 0.7

All combinations produce fine-grained MECE segments.

An ELSE bucket ensures collective exhaustiveness.

Small segments (<500 users) can be merged into ELSE for practical campaign targeting.

Scoring & Reranker Logic

Each segment is scored across four dimensions:

Conversion Potential = avg(engagement × recency)

Profitability = avg(profitability_score)

Lift vs Control = simulated or historical A/B test improvement

Normalized Size = segment size / total universe size

Overall Score (weighted sum):

overall_score = 0.4*conversion + 0.4*profitability + 0.1*lift + 0.1*size


Segments are then reranked by overall score to prioritize high-value audiences.

Example: Before/After Reranker
Segment Name	Size	Overall Score	Before Rerank	After Rerank
LowAOV_LowEng_LowProf	12000	0.52	1	8
MidAOV_MidEng_HighProf	5000	0.62	3	3
HighAOV_HighEng_HighProf	3200	0.76	5	1

High-value segments rise to the top after reranking, ensuring marketing efforts focus on the most profitable & engaged users.

Outputs

output/segments_summary.csv – CSV summary of all segments

output/segments_summary.json – JSON summary

Optional visualization: Pie chart of segment distribution

Dependencies

Python ≥ 3.10

pandas

numpy

pytest

matplotlib

Install all dependencies via:

pip install -r requirements.txt

Next Steps / Enhancements

Merge very small segments (<500 users) into ELSE bucket

Integrate real lift / A/B test data for more accurate scoring

Extend segmentation features to include recency, number of cart items, session activity

Author

Gopika Aravind

Electronics & Communication Engineering | Atria Institute of Technology

AI/ML Research & Growth Analytics Enthusiast

Contact: [your-email@example.com
]


---

### ✅ **Next Actions After Adding README**

1. Save this as `README.md` in the repo root.  
2. Stage, commit, and push:

```bash
git add README.md
git commit -m "Add polished README with scoring and reranker explanation"
git push
